# Redis 集群

Redis 集群提供了一个运行redis实例的方式，该方式下数据会被自动的在多个reids节点中分享。在分区的时候，Redis 集群还提供了一定程度的可用性，即在实际应用中，当几个节点挂掉或者无法通讯的时候，系统还可以持续运行。不过当大面积的节点出问题的时候集群还是会停止（比如当主要的master挂掉了的时候）

那么在实际应用中，Redis集群可以做到什么？

* 自动切分数据集到多个节点上的能力
* 当部分节点宕机或无法通讯的情况下仍可继续处理命令


## Redis 集群 TCP 端口

每一个redis集群的节点需要开通两个TCP端口。一个是用于客户端的Redis TCP，如6379。另一个由客户端加10000所得，如16379，用于Redis集群总线连接。 这是一个用户 节点对节点的 二进制协议通讯通道。集群总线是用来处理节点的失效检测，配置更新，灾备授权等事情。客户端应该连接redis普通命令端口（即之前提到的6370）而绝对不要去直接连接集群总线端口。不过还是要保证这两个端口在防火墙里面打开，否则redis集群内的节点无法互相通信。

集群总线端口总是比命令端口高10000。

注意：为了让redis集群运作正常，你需要在每个节点上：

  1. 把客户端用来连接redis的普通客户端通讯端口（一般是6379）对所有客户端和其他节点开放（别的节点也会用这个端口来迁移数据）
  2. 所有节点之间的集群总线端口（客户端口加上10000所得）必须互相开通

如果你没有同时打开这两个端口，集群就无法正常工作了

集群总线使用了一种不同的二进制协议，供节点和节点之间交换信息用。该协议可以让节点和节点之间以更小的流量和和更短的时间来交换信息。

## Redis 集群数据分片

Redis集群用的不是基于哈希值的分片方式，用的是另一种不同的分片方式。在该分片方式下所有键在概念上都是我们称之为哈希槽的一部分。Redis集群有16384个哈希槽。当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。

Redis集群中的每个节点都存放了一些哈希槽。所以举例来说，比如你有3个节点：

* 节点A 保存了从 0 到 5500 的哈希槽
* 节点B 保存了从 5501 到 11000的哈希槽
* 节点C 保存了从 11001 到 16384 的哈希槽

这么做让集群增加或者减少节点变得很简单。比如我要增加一个节点D，我只需要从节点ABC移动一部分哈希槽到D。如果我要从节点中去除节点A，我只需要把节点A上的哈希槽移动到节点B或者C。当节点A的哈希槽被全部移走了之后，我就可以将它从节点中完全去除。

因为把哈希槽从一个节点移动到另外一个节点并不需要停止集群， 所以增加、删除节点或者在各节点间调整哈希槽的占有率的时候是不用停止集群的。Redis集群支持在一条命令里面对同一个哈希槽的多个键同时操作（或者在一个事务中，或者在一个lua脚本执行过程中）。用户可以通过哈希标签强制的把多个键放到一个哈希槽里面。在Redis集群手册中可以查到哈希标签的相关说明, 不过归纳成一句话就是：当有在key里面写上段包含在{...}中的文字的时候，之后大括号{...}中的文字会被计算成哈希键。比如有两个key一个名叫 this{foo}key 另一个名叫 another{foo}key ，这两个key会被归纳到同一个哈希槽里面。这样这两个key就可以在一个命令中同时进行操作了。

## Redis 集群主从模型

了在部分节点失败或者无法通信的情况下集群仍然可用，Redis 集群采用了一种 主从模型。在该模型下每一个哈希槽都会被从master端复制N份到slave节点。在我们的例子中有三个节点分别是ABC，如果节点B挂掉了，集群就无法继续工作，因为从5501到11000的哈希槽就没了。

不过如果当集群被创建的时候（迟些时候也可以）我们给每一个master节点增加一个slave从节点。模型变成这样：集群中有三个节点A，B，C，以及他们各自的从节点 A1，B1，C1，当节点B挂掉的时候，系统还可以正常运行。

节点B1是用来做为节点B的镜像的。当节点B挂掉了，集群会选举B1作为新的master节点，并继续运行下去。

不过要注意当节点B和节点B1都挂掉的时候，redis集群还是无法继续运行。

## Redis 集群一致性保证

Redis 集群并不能保证数据的强一致性。在实际应用中这意味着在特定的情况下，就算Redis 集群告知客户端已经收到了写请求，这个写请求仍然有可能丢失。Redis集群之所以会丢失写请求的首要原因是：它采用了异步的复制机制。在写的时候会经历以下的步骤:

  1. 你的客户端发送了一个写请求给master B 节点
  2. master B 节点回复了一个OK给你的客户端。
  3. master B 节点把这个写请求传播到它的 slave B1, B2, B3 节点上去。

正如你所见， B节点并不会等到B1，B2，B3节点都回复它之后才回复OK给客户端。因为这样会造成redis集群过高的延迟度。所以如果你的客户端正在写些什么东西，节点B又告知你的客户端它收到了写请求，但是在它把这个写请求发送给它的slave节点们之前，节点B挂了，那么其中一个slave节点（假设它还没收到写请求）被选举为master那么你这个写请求就永久的丢失了。

很多数据库被配置成每秒刷新一次数据到磁盘，他们都会发生非常类似的事情。所以你可以根据以往使用传统数据库（这些数据库都不是基于分布式的）的经验很容易的推导出这种场景。同样的你也可以强制让数据库每次都等到写入了磁盘才回复客户端，这样就可以保证一致性，但是这往往导致了系统的性能急剧下降。同样的如果你把Reids集群设计成同步复制机制也会造成性能低下。

从根本上说这是一种用一致性来换取性能的交易。

当非常有必要的时候，Redis集群也支持同步写入。它通过实现WAIT命令来实现。这样一来基本不会丢失写操作。但是请注意就算你使用了同步复制，Redis集群也不能达到强一致性，因为：总是会遇到某些更复杂的错误场景，在这些场景下slave节点在被选举为master的时候还没收到写请求。

还有一个需要注意的会丢失数据的情况。当进行一次网络网络分裂的时候某个客户端被分配到一个拥有很少节点的区域中的情况。

就拿我们的6节点例子（master是ABC，slave是A1，B1，C1），此时有一个客户端，我们称之为Z1。当网络分裂后，有可能有这种情况：现在有2方，一方是 A,C,A1，B1，C1，另一方是B和Z1。Z1依然可以写入B，而且B也会接受来自Z1的写请求。如果这次网络分裂在很短的时间内被修复， 集群依然会保持正常运行。 然而如果浙西网络分裂持续了较长时间，长到足够B1在多数方被选举为master。那么Z1发送给B的写请求都会丢失。

注意， 在网络分裂出现期间， 客户端 Z1 可以向主节点 B 发送写命令的最大时间是有限制的， 这一时间限制称为节点超时时间（node timeout）， 是 Redis 集群的一个重要的配置选项：

* 对于大多数一方来说， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么集群会将这个主节点视为下线， 并使用从节点来代替这个主节点继续工作。

* 对于少数一方， 如果一个主节点未能在节点超时时间所设定的时限内重新联系上集群， 那么它将停止处理写命令， 并向客户端报告错误。
